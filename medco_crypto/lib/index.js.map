{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import {Point, Scalar} from \"@dedis/kyber\";\nimport {newCurve} from \"@dedis/kyber/curve\";\nimport {PointToInt} from \"./mapping\";\n\n// CipherText is an ElGamal encrypted point.\nclass CipherText {\n\tK: Point;\n\tC: Point;\n\n\tconstructor(K: Point, C: Point) {\n\t\tthis.K = K;\n\t\tthis.C = C;\n\t}\n\n\ttoString(): string {\n\t\tlet cstr = \"nil\";\n\t\tlet kstr = cstr;\n\t\tif (this.C != null) {\n\t\t\tcstr = this.C.toString().slice(1, 7)\n\t\t}\n\t\tif (this.K != null) {\n\t\t\tkstr = this.K.toString().slice(1, 7)\n\t\t}\n\t\tlet str = \"\";\n\t\treturn str.concat(\"CipherText{\",cstr,\",\",kstr,\"}\")\n\t}\n\n}\n\nconst arrayBufferToBuffer = require('arraybuffer-to-buffer');\nconst curve25519 = newCurve(\"edwards25519\");\n\n// Encryption\n//______________________________________________________________________________________________________________________\n\n/**\n * Encrypts an integer with the cothority key\n * @returns {CipherText}\n * @param pk\n * @param x\n */\nexport function EncryptInt(pk: Point, x: number): CipherText {\n\treturn encryptPoint(pk, IntToPoint(x))\n}\n\n/**\n * Maps an integer to a point in the elliptic curve.\n * @returns {Point}\n * @param x\n */\nfunction IntToPoint(x: number): Point {\n\tlet B = curve25519.point().base();\n\tlet i = curve25519.scalar().setBytes(toBytesInt32(x));\n\treturn curve25519.point().mul(i, B)\n}\n\n/**\n * Creates an elliptic curve point from a non-encrypted point and encrypt it using ElGamal encryption.\n * @returns {CipherText}\n * @param pk\n * @param M\n */\nfunction encryptPoint(pk: Point, M: Point): CipherText {\n    let B = curve25519.point().base();\n    let r = curve25519.scalar().pick(); // ephemeral private key\n    // ElGamal-encrypt the point to produce ciphertext (K,C).\n    let K = curve25519.point().mul(r, B);\t// ephemeral DH public key\n    let S = curve25519.point().mul(r, pk);\t// ephemeral DH shared secret\n    let C = curve25519.point().add(S, M);   // message blinded with secret\n    return new CipherText(K,C)\n}\n\n// Decryption\n//______________________________________________________________________________________________________________________\n\n/**\n * Decrypts an integer from an ElGamal cipher text where integer are encoded in the exponent.\n * @returns {number}\n * @param prikey\n * @param cipher\n */\nexport function DecryptInt(prikey: Scalar, cipher: CipherText): number {\n\tlet M = decryptPoint(prikey, cipher);\n\treturn PointToInt[M.toString()];\n}\n\n/**\n * Decrypts an elliptic point from an El-Gamal cipher text.\n * @returns {Point}\n * @param prikey\n * @param c\n */\nfunction decryptPoint(prikey: Scalar, c: CipherText): Point {\n\tlet S = curve25519.point().mul(prikey, c.K);\t// regenerate shared secret\n\treturn curve25519.point().sub(c.C, S)\t\t    // use to un-blind the message\n}\n\n// Utilities\n//______________________________________________________________________________________________________________________\n\n/**\n   * Generates a random pair of keys for the user to be used during this instance.\n   * @returns {[string, string]}\n   */\nexport function GenerateKeyPair() {\n\tlet privKey = curve25519.scalar().pick();\n\tlet pubKey = curve25519.point().mul(privKey, null);\n\treturn [privKey, pubKey];\n}\n\n// Representation\n//______________________________________________________________________________________________________________________\n\n\n\n// Marshal\n//______________________________________________________________________________________________________________________\n\n/**\n * Converts a Number to Buffer of\n * @returns {Buffer}\n * @param x\n */\nfunction toBytesInt32 (x: number): Buffer {\n\tlet arr = new ArrayBuffer(4); // an Int32 takes 4 bytes\n\tlet view = new DataView(arr);\n\tview.setUint32(0, x, true); // byteOffset = 0; litteEndian = false\n\treturn arrayBufferToBuffer(arr);\n}\n\n\n\n\n\n"]}